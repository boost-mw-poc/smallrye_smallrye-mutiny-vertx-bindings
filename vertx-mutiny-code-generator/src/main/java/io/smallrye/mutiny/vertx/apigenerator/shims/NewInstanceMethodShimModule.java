package io.smallrye.mutiny.vertx.apigenerator.shims;

import java.util.ArrayList;
import java.util.List;

import javax.lang.model.element.Modifier;

import com.github.javaparser.StaticJavaParser;
import com.github.javaparser.ast.type.TypeParameter;
import com.github.javaparser.javadoc.Javadoc;
import com.github.javaparser.javadoc.description.JavadocDescription;
import com.palantir.javapoet.ClassName;
import com.palantir.javapoet.MethodSpec;
import com.palantir.javapoet.TypeSpec;
import com.palantir.javapoet.TypeVariableName;

import io.smallrye.mutiny.vertx.TypeArg;
import io.smallrye.mutiny.vertx.apigenerator.analysis.BaseShimMethod;
import io.smallrye.mutiny.vertx.apigenerator.analysis.Shim;
import io.smallrye.mutiny.vertx.apigenerator.analysis.ShimClass;
import io.smallrye.mutiny.vertx.apigenerator.analysis.ShimMethodParameter;
import io.smallrye.mutiny.vertx.apigenerator.analysis.ShimModule;
import io.smallrye.mutiny.vertx.apigenerator.collection.VertxGenInterface;

/**
 * Declares the `newInstance` method taking the {@code delegate} object as parameter.
 */
public class NewInstanceMethodShimModule implements ShimModule {
    @Override
    public boolean accept(ShimClass shim) {
        return true;
    }

    @Override
    public void analyze(ShimClass shim) {
        shim.addMethod(new NewInstanceMethod(this, shim));
        if (!shim.getSource().getTypeParameters().isEmpty()) {
            List<ShimMethodParameter> parameters = new ArrayList<>();
            parameters.add(new ShimMethodParameter("delegate", shim.getSource().getType(), null));
            int index = 0;
            for (TypeParameter tv : shim.getSource().getTypeParameters()) {
                parameters.add(new ShimMethodParameter("typeArg_" + index,
                        StaticJavaParser.parseClassOrInterfaceType(TypeArg.class.getName())
                                .setTypeArguments(StaticJavaParser.parseTypeParameter(tv.getNameAsString())),
                        null));
                index++;
            }
            shim.addMethod(new NewInstanceMethodWithTypeArgs(this, shim, parameters));
        }
    }

    /**
     * The constructor taking the delegate as parameter.
     *
     * <pre>
     * public shim(T delegate) {
     *     // if has parent
     *     super(delegate);
     *
     *     this.delegate = delegate;
     *
     *     // for each shimType parameter
     *     this.__typeArg_0 = io.smallrye.mutiny.vertx.TypeArg.unknown();
     * }
     * </pre>
     */
    private static class NewInstanceMethod extends BaseShimMethod {
        private final VertxGenInterface source;

        public NewInstanceMethod(ShimModule module, ShimClass shim) {
            super(module,
                    "newInstance",
                    shim.getType(),
                    List.of(new ShimMethodParameter("delegate", shim.getSource().getType(), null)),
                    List.of(),
                    true,
                    false,
                    new Javadoc(JavadocDescription
                            .parseText("Creates a new instance of the {@code " + shim.getSimpleName() + "}.")),
                    null);
            this.source = shim.getSource();
        }

        @Override
        public void generate(ShimClass shim, TypeSpec.Builder builder) {
            MethodSpec.Builder method = MethodSpec.methodBuilder(getName());
            method.addModifiers(Modifier.PUBLIC);
            method.addModifiers(Modifier.STATIC);
            method.addJavadoc(getJavadoc().toText());
            method.returns(Shim.getTypeNameFromType(shim.getType()));
            method.addParameter(Shim.getTypeNameFromType(shim.getSource().getType()), "delegate");

            method.addComment("Generated by " + declaredBy().getClass().getName());

            String typeparams = "";
            if (!source.getDeclaration().getTypeParameters().isEmpty()) {
                typeparams = "<";
                typeparams += String.join(", ",
                        source.getDeclaration().getTypeParameters().stream().map(TypeParameter::getNameAsString).toList());
                typeparams += ">";
                // Also generate the type arguments for the method
                source.getDeclaration().getTypeParameters()
                        .forEach(tp -> method.addTypeVariable(TypeVariableName.get(tp.getNameAsString())));
            }

            // We must not add the generics here, because it will not work if the class is not concrete
            method.addStatement("return delegate != null ? new $T$L$L(delegate) : null",
                    ClassName.bestGuess(shim.getFullyQualifiedName()), source.isConcrete() ? "" : "Impl", typeparams);
            builder.addMethod(method.build());
        }

    }

    private static class NewInstanceMethodWithTypeArgs extends BaseShimMethod {
        private final VertxGenInterface source;

        public NewInstanceMethodWithTypeArgs(ShimModule module, ShimClass shim, List<ShimMethodParameter> parameters) {
            super(module,
                    "newInstance",
                    shim.getType(),
                    parameters,
                    List.of(),
                    true,
                    false,
                    new Javadoc(JavadocDescription
                            .parseText("Creates a new instance of the {@code " + shim.getSimpleName() + "}.")),
                    null);
            this.source = shim.getSource();
        }

        @Override
        public void generate(ShimClass shim, TypeSpec.Builder builder) {
            MethodSpec.Builder method = MethodSpec.methodBuilder(getName());
            method.addModifiers(Modifier.PUBLIC);
            method.addModifiers(Modifier.STATIC);
            method.addJavadoc(getJavadoc().toText());
            method.returns(Shim.getTypeNameFromType(shim.getType()));

            for (ShimMethodParameter parameter : getParameters()) {
                var cn = Shim.getTypeNameFromType(parameter.shimType());
                var name = parameter.name();
                method.addParameter(cn, name);
            }

            method.addComment("Generated by " + declaredBy().getClass().getName());

            String typeparams = "";
            if (!source.getDeclaration().getTypeParameters().isEmpty()) {
                typeparams = "<";
                typeparams += String.join(", ",
                        source.getDeclaration().getTypeParameters().stream().map(TypeParameter::getNameAsString).toList());
                typeparams += ">";
                // Also generate the type arguments for the method
                source.getDeclaration().getTypeParameters()
                        .forEach(tp -> method.addTypeVariable(TypeVariableName.get(tp.getNameAsString())));
            }

            // We must not add the generics here, because it will not work if the class is not concrete
            method.addStatement("return delegate != null ? new $T$L$L($L) : null",
                    ClassName.bestGuess(shim.getFullyQualifiedName()),
                    source.isConcrete() ? "" : "Impl",
                    typeparams,
                    String.join(", ", getParameters().stream().map(ShimMethodParameter::name).toList()));
            builder.addMethod(method.build());
        }

    }
}
