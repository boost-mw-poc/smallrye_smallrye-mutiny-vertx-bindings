{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Overview Eclipse Vert.x is the leading toolkit for writing reactive applications on the JVM. While the Vert.x core APIs expose asynchronous programming through callbacks and promise / future , code generators offer bindings to other asynchronous programming models, including: Kotlin coroutines , and RxJava 1, 2 and 3 . This project offers Vert.x binding for Mutiny, an intuitive event-driven reactive programming library for Java . Getting the bindings The bindings can be accessed from the following Maven coordinates: Group: io.smallrye.reactive Artifact: smallrye-mutiny-vertx-<MODULE> where MODULE refers to a Vert.x module, such as core , pg-client , web-client , etc. The Mutiny bindings are modular If you are familiar with other Vert.x bindings such as those for RxJava then you need to be aware that the Mutiny bindings are offered on a per-module basis. For instance the RxJava 3 bindings are exposed through the io.vertx:vertx-rx-java3 dependency, and that vertx-rx-java3 has optional dependencies on the whole Vert.x stack . We think that it is cleaner to offer bindings on a per-module basis, so your project does not have optional dependencies on modules of the Vert.x stack that you don't consume. The full list of supported modules from the Vert.x stack is available at https://github.com/smallrye/smallrye-mutiny-vertx-bindings/tree/main/vertx-mutiny-clients A short example The following self-contained JBang script shows some of the features of the Vert.x Mutiny bindings (see the highlights): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 ///usr/bin/env jbang \"$0\" \"$@\" ; exit $? //DEPS io.smallrye.reactive:smallrye-mutiny-vertx-core:2.6.0 import io.smallrye.mutiny.Uni ; import io.smallrye.mutiny.vertx.core.AbstractVerticle ; import io.vertx.core.DeploymentOptions ; import io.vertx.mutiny.core.Vertx ; public class hello { static class MyVerticle extends AbstractVerticle { private long counter = 0 L ; /* * Asynchronous start completion notification through a Uni. * This is the Mutiny variant of `start(Promise<Void>)` in plain Vert.x. */ @Override public Uni < Void > asyncStart () { /* * Vert.x stream (ticks every 2 seconds) to Mutiny stream (Multi), * then increment a counter. */ vertx . periodicStream ( 2000L ) . toMulti () . subscribe (). with ( tick -> counter ++ ); /* * HTTP endpoint, where `listen` returns a `Uni<HttpServer>`. * Notifies of the start procedure completion by replacing and * returning the`Uni<HttpServer>` by `Uni<Void>`. */ return vertx . createHttpServer () . requestHandler ( req -> req . response (). endAndForget ( \"@\" + counter )) . listen ( 8080 ) . onItem () . invoke (() -> System . out . println ( \"See http://127.0.0.1:8080\" )) . onFailure () . invoke ( Throwable :: printStackTrace ) . replaceWithVoid (); } } /* * Main method, deploys a verticle and awaits for the completion with * an `*AndAwait()` method. */ public static void main ( String ... args ) { var vertx = Vertx . vertx (); System . out . println ( \"Deployment Starting\" ); vertx . deployVerticleAndAwait ( MyVerticle :: new , new DeploymentOptions ()); System . out . println ( \"Deployment completed\" ); } } This script can be run with ./hello.java or jbang run hello.java , and exposes a HTTP server on port 8080: $ ./hello.java [jbang] Building jar... Deployment Starting See http://127.0.0.1:8080 Deployment completed The HTTP server responds to any HTTP request with the current value of a counter that is incremented every 2 seconds: $ http :8080 HTTP/1.1 200 OK content-length: 2 @1 $ http :8080 HTTP/1.1 200 OK content-length: 2 @2 The deployed verticle uses the Mutiny API, where the start(Promise<Void>) method is replaced by asyncStart() method that returns a Uni<Void> . The code also shows how to convert Vert.x streams into Mutiny Multi streams, and how to await for the verticle deployment to complete.","title":"Overview"},{"location":"#overview","text":"Eclipse Vert.x is the leading toolkit for writing reactive applications on the JVM. While the Vert.x core APIs expose asynchronous programming through callbacks and promise / future , code generators offer bindings to other asynchronous programming models, including: Kotlin coroutines , and RxJava 1, 2 and 3 . This project offers Vert.x binding for Mutiny, an intuitive event-driven reactive programming library for Java .","title":"Overview"},{"location":"#getting-the-bindings","text":"The bindings can be accessed from the following Maven coordinates: Group: io.smallrye.reactive Artifact: smallrye-mutiny-vertx-<MODULE> where MODULE refers to a Vert.x module, such as core , pg-client , web-client , etc. The Mutiny bindings are modular If you are familiar with other Vert.x bindings such as those for RxJava then you need to be aware that the Mutiny bindings are offered on a per-module basis. For instance the RxJava 3 bindings are exposed through the io.vertx:vertx-rx-java3 dependency, and that vertx-rx-java3 has optional dependencies on the whole Vert.x stack . We think that it is cleaner to offer bindings on a per-module basis, so your project does not have optional dependencies on modules of the Vert.x stack that you don't consume. The full list of supported modules from the Vert.x stack is available at https://github.com/smallrye/smallrye-mutiny-vertx-bindings/tree/main/vertx-mutiny-clients","title":"Getting the bindings"},{"location":"#a-short-example","text":"The following self-contained JBang script shows some of the features of the Vert.x Mutiny bindings (see the highlights): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 ///usr/bin/env jbang \"$0\" \"$@\" ; exit $? //DEPS io.smallrye.reactive:smallrye-mutiny-vertx-core:2.6.0 import io.smallrye.mutiny.Uni ; import io.smallrye.mutiny.vertx.core.AbstractVerticle ; import io.vertx.core.DeploymentOptions ; import io.vertx.mutiny.core.Vertx ; public class hello { static class MyVerticle extends AbstractVerticle { private long counter = 0 L ; /* * Asynchronous start completion notification through a Uni. * This is the Mutiny variant of `start(Promise<Void>)` in plain Vert.x. */ @Override public Uni < Void > asyncStart () { /* * Vert.x stream (ticks every 2 seconds) to Mutiny stream (Multi), * then increment a counter. */ vertx . periodicStream ( 2000L ) . toMulti () . subscribe (). with ( tick -> counter ++ ); /* * HTTP endpoint, where `listen` returns a `Uni<HttpServer>`. * Notifies of the start procedure completion by replacing and * returning the`Uni<HttpServer>` by `Uni<Void>`. */ return vertx . createHttpServer () . requestHandler ( req -> req . response (). endAndForget ( \"@\" + counter )) . listen ( 8080 ) . onItem () . invoke (() -> System . out . println ( \"See http://127.0.0.1:8080\" )) . onFailure () . invoke ( Throwable :: printStackTrace ) . replaceWithVoid (); } } /* * Main method, deploys a verticle and awaits for the completion with * an `*AndAwait()` method. */ public static void main ( String ... args ) { var vertx = Vertx . vertx (); System . out . println ( \"Deployment Starting\" ); vertx . deployVerticleAndAwait ( MyVerticle :: new , new DeploymentOptions ()); System . out . println ( \"Deployment completed\" ); } } This script can be run with ./hello.java or jbang run hello.java , and exposes a HTTP server on port 8080: $ ./hello.java [jbang] Building jar... Deployment Starting See http://127.0.0.1:8080 Deployment completed The HTTP server responds to any HTTP request with the current value of a counter that is incremented every 2 seconds: $ http :8080 HTTP/1.1 200 OK content-length: 2 @1 $ http :8080 HTTP/1.1 200 OK content-length: 2 @2 The deployed verticle uses the Mutiny API, where the start(Promise<Void>) method is replaced by asyncStart() method that returns a Uni<Void> . The code also shows how to convert Vert.x streams into Mutiny Multi streams, and how to await for the verticle deployment to complete.","title":"A short example"},{"location":"api-translation/","text":"API translation The Vert.x Mutiny bindings are generated from the existing Vert.x APIs. Vert.x and asynchronous operation methods Vert.x is a toolkit that simplifies asynchronous I/O programming. The Vert.x APIs rely on simple conventions to denote methods doing asynchronous operations: methods that accept a callback as a last parameter, and methods that return a Vert.x Future . Vert.x has historically relied on callbacks, as in: public void someOperation ( Foo a , Bar b , Baz c , Handler < AsyncResult < T >> handler ) { // (...) } Here someOperation is a method where a , b and c are parameters , and handler is a callback : the callback is notified when the asynchronous operation done in someOperation completes ( continuation ), and callbacks are always passed as a last parameter of type Handler<AsyncResult<T>> , and AsyncResult encapsulates an asynchronous result of type T , or a failure. Since Vert.x 4 asynchronous operations can also be defined by returning a Future<T> , as in: public Future < T > someOperation ( Foo a , Bar b , Baz c ) { // (...) } Code generators (e.g., Mutiny, RxJava, Kotlin coroutines, etc) can spot these methods and derive their own shim APIs . For instance with Mutiny someOperation becomes: public Uni < T > someOperation ( Foo a , Bar b , Baz c ) { // (...) } What does the Mutiny code generator do? The code generator is applied to selected modules from the Vert.x stack. The translation rules are the following. Rule Translation io.vertx package io.vertx.mutiny package Asynchronous method A method returning a Uni<T> ReadStreams<T> Consumed as a Multi<T> WriteStreams<T> Consumed as a Reactive Streams Subscriber<T> Because Mutiny is a Reactive Streams compliant implementation, the generated shims also adapt the Vert.x back-pressure protocol to that of Reactive Streams . Method erasure The Mutiny code generator erases methods. Given an asynchronous method foo(Handler<AsyncResult<T>>) , then it is not present in the generated shim as it is replaced with Uni<T> foo() . Helper methods Given an asynchronous operation method, the Mutiny code generator also provides 2 further variants: xAndAwait() to block the caller thread until the outcome is received, or throw a RuntimeException when a failure arises, and xAndForget() to trigger the operation then discard the outcome (failures will be logged). Given the someOperation method above, the generator provides these 3 methods: // The canonical Mutiny method public Uni < T > someOperation ( Foo a , Bar b , Baz c ) { // (...) } // Blocks, may throw a RuntimeException public T someOperationAndAwait ( Foo a , Bar b , Baz c ) { // (...) } // Does not block, the result or failure is discarded public void someOperationAndForget ( Foo a , Bar b , Baz c ) { // (...), } Generate Mutiny variants from your own APIs Vert.x uses an open code generator, so you can generate Mutiny APIs for your own asynchronous interfaces. The code generator is available from the io.smallrye.reactive:vertx-mutiny-generator artifact. It works with the Vert.x io.vertx:vertx-codegen annotation processor. You can generate bindings by having the artifacts on the classpath for annotation processing at compilation time, or you may use other ways in your builds. The code for this project shows how to generate the files using Maven plugins.","title":"API Translation"},{"location":"api-translation/#api-translation","text":"The Vert.x Mutiny bindings are generated from the existing Vert.x APIs.","title":"API translation"},{"location":"api-translation/#vertx-and-asynchronous-operation-methods","text":"Vert.x is a toolkit that simplifies asynchronous I/O programming. The Vert.x APIs rely on simple conventions to denote methods doing asynchronous operations: methods that accept a callback as a last parameter, and methods that return a Vert.x Future . Vert.x has historically relied on callbacks, as in: public void someOperation ( Foo a , Bar b , Baz c , Handler < AsyncResult < T >> handler ) { // (...) } Here someOperation is a method where a , b and c are parameters , and handler is a callback : the callback is notified when the asynchronous operation done in someOperation completes ( continuation ), and callbacks are always passed as a last parameter of type Handler<AsyncResult<T>> , and AsyncResult encapsulates an asynchronous result of type T , or a failure. Since Vert.x 4 asynchronous operations can also be defined by returning a Future<T> , as in: public Future < T > someOperation ( Foo a , Bar b , Baz c ) { // (...) } Code generators (e.g., Mutiny, RxJava, Kotlin coroutines, etc) can spot these methods and derive their own shim APIs . For instance with Mutiny someOperation becomes: public Uni < T > someOperation ( Foo a , Bar b , Baz c ) { // (...) }","title":"Vert.x and asynchronous operation methods"},{"location":"api-translation/#what-does-the-mutiny-code-generator-do","text":"The code generator is applied to selected modules from the Vert.x stack. The translation rules are the following. Rule Translation io.vertx package io.vertx.mutiny package Asynchronous method A method returning a Uni<T> ReadStreams<T> Consumed as a Multi<T> WriteStreams<T> Consumed as a Reactive Streams Subscriber<T> Because Mutiny is a Reactive Streams compliant implementation, the generated shims also adapt the Vert.x back-pressure protocol to that of Reactive Streams . Method erasure The Mutiny code generator erases methods. Given an asynchronous method foo(Handler<AsyncResult<T>>) , then it is not present in the generated shim as it is replaced with Uni<T> foo() .","title":"What does the Mutiny code generator do?"},{"location":"api-translation/#helper-methods","text":"Given an asynchronous operation method, the Mutiny code generator also provides 2 further variants: xAndAwait() to block the caller thread until the outcome is received, or throw a RuntimeException when a failure arises, and xAndForget() to trigger the operation then discard the outcome (failures will be logged). Given the someOperation method above, the generator provides these 3 methods: // The canonical Mutiny method public Uni < T > someOperation ( Foo a , Bar b , Baz c ) { // (...) } // Blocks, may throw a RuntimeException public T someOperationAndAwait ( Foo a , Bar b , Baz c ) { // (...) } // Does not block, the result or failure is discarded public void someOperationAndForget ( Foo a , Bar b , Baz c ) { // (...), }","title":"Helper methods"},{"location":"api-translation/#generate-mutiny-variants-from-your-own-apis","text":"Vert.x uses an open code generator, so you can generate Mutiny APIs for your own asynchronous interfaces. The code generator is available from the io.smallrye.reactive:vertx-mutiny-generator artifact. It works with the Vert.x io.vertx:vertx-codegen annotation processor. You can generate bindings by having the artifacts on the classpath for annotation processing at compilation time, or you may use other ways in your builds. The code for this project shows how to generate the files using Maven plugins.","title":"Generate Mutiny variants from your own APIs"}]}